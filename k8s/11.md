# Manually working with secrets

### Kubectl
1. Create secret using **kubectl**
```bash
  kubectl create secret generic my-secret --from-literal=MY_USER=myuser --from-literal=MY_PASS=mypassword
```
```
  secret/my-secret created
```

2. Verify that secret created successfully
```bash
  kubectl get secrets my-secret -o yaml
```
```yaml
  apiVersion: v1
  data:
    MY_PASS: bXlwYXNzd29yZA==
    MY_USER: bXl1c2Vy
  kind: Secret
  metadata:
    creationTimestamp: "2025-03-08T16:34:41Z"
    name: my-secret
    namespace: default
    resourceVersion: "11920"
    uid: 90511cfb-b942-4427-b15a-b28192a6ee76
  type: Opaque
```

```bash
  kubectl get secret my-secret -o jsonpath='{.data}'
```
```json
  {"MY_PASS":"bXlwYXNzd29yZA==","MY_USER":"bXl1c2Vy"}
```

```bash
  echo "bXlwYXNzd29yZA==" | base64 --decode
```
```
  mypassword
```

```bash
  echo "bXl1c2Vy" | base64 --decode
```
```
  myuser
```

### Helm

1. I created **secrets.yaml** inside **templates** for my python app
```yaml
    apiVersion: v1
    kind: Secret
    metadata:
      name: my-secret
    type: Opaque
    data:
      MY_USER: bXl1c2Vy
      MY_PASS: bXlwYXNzd29yZA==
```

2. I added env section to **deployment.yml** for my python app
```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: {{ .Chart.Name }}
    labels:
      {{- include "common.labels" . | nindent 4 }}
      app-python/special-label: "app-python"
  spec:
    selector:
      matchLabels:
        app.kubernetes.io/name: {{ .Chart.Name }}
    template:
      metadata:
        labels:
          {{- include "common.labels" . | nindent 8 }}
      spec:
        containers:
          - name: {{ .Chart.Name }}
            image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
            ports:
              - name: http
                containerPort: {{ .Values.service.port }}
                protocol: TCP
            env:
              - name: MY_USER
                valueFrom:
                  secretKeyRef:
                    name: my-secret
                    key: MY_USER
              - name: MY_PASS
                valueFrom:
                  secretKeyRef:
                    name: my-secret
                    key: MY_PASS
```

3. I upgraded my deployment to add secrets
Firstly we need to add plugin to work with secrets
```bash
  helm plugin install https://github.com/jkroepke/helm-secrets
```
```
  Installed plugin: secrets
```

then upgrade deployment

```bash
  helm secrets upgrade --install  app-python ./app-python -n default -f ./app-python/templates/secrets.yaml
```
```
  Release "app-python" has been upgraded. Happy Helming!
  NAME: app-python
  LAST DEPLOYED: Sat Mar  8 20:18:24 2025
  NAMESPACE: default
  STATUS: deployed
  REVISION: 3
  NOTES:
  1. Get the application URL by running these commands:
    export POD_NAME=$(kubectl get pods --namespace default -l "app.kubernetes.io/name=app-python,app.kubernetes.io/instance=app-python" -o jsonpath="{.items[0].metadata.name}")
    export CONTAINER_PORT=$(kubectl get pod --namespace default $POD_NAME -o jsonpath="{.spec.containers[0].ports[0].containerPort}")
    echo "Visit http://127.0.0.1:8080 to use your application"
    kubectl --namespace default port-forward $POD_NAME 8080:$CONTAINER_PORT
```

4. Verify that secrets was applied successfully
```bash
  kubectl exec app-python-575d5fd77d-7rdm7 -- printenv | grep MY_
```
```
  MY_USER=myuser
  MY_PASS=mypassword
```

# Working with vault
1. Install and run hashicorp vault
```bash
  helm repo add hashicorp https://helm.releases.hashicorp.com
```
```
  "hashicorp" has been added to your repositories
```

```bash
  helm repo update
```
```
  Hang tight while we grab the latest from your chart repositories...
  ...Successfully got an update from the "hashicorp" chart repository
  Update Complete. ⎈Happy Helming!⎈
```

```bash
  helm install vault hashicorp/vault --set "server.dev.enabled=true" --namespace vault --create-namespace
```
```
NAME: vault
LAST DEPLOYED: Sat Mar  8 20:54:33 2025
NAMESPACE: vault
STATUS: deployed
REVISION: 1
NOTES:
Thank you for installing HashiCorp Vault!

Now that you have deployed Vault, you should look over the docs on using
Vault with Kubernetes available here:

https://developer.hashicorp.com/vault/docs


Your release is named vault. To learn more about the release, try:

  $ helm status vault
  $ helm get manifest vault
```

```bash
  kubectl get pods -n vault
```
```
NAME                                   READY   STATUS    RESTARTS   AGE
vault-0                                1/1     Running   0          50s
vault-agent-injector-6c5fcb994-xhwqp   1/1     Running   0          50s
```

2. Log in to vault
```bash
  kubectl port-forward svc/vault 8200:8200 -n vault
```
We need this to access vault from machine, because we are using minikube
```bash
  export VAULT_ADDR=http://127.0.0.1:8200
  vault login root
```
```
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                root
token_accessor       4S0h95QxMyGSO2U35KcptDDb
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
```

3. Set a secret in vault
```bash
  vault kv put internal/database/config username="db-readonly-username" password="db-secret-password"
```
```
======== Secret Path ========
internal/data/database/config

======= Metadata =======
Key                Value
---                -----
created_time       2025-03-08T20:24:45.802902427Z
custom_metadata    <nil>
deletion_time      n/a
destroyed          false
version            1
```

4. Set up kubernetes auth
```bash
  vault auth enable kubernetes
```
```
  Success! Enabled kubernetes auth method at: kubernetes/
```

```bash
  kubectl create sa vault-auth -n default 
```
```
  serviceaccount/vault-auth created
```

Add host
```bash
   vault write auth/kubernetes/config \
      kubernetes_host="https://$KUBERNETES_PORT_443_TCP_ADDR:443"
```
```
  Success! Data written to: auth/kubernetes/config
```

Create policy
```bash
  vault policy write readonly - <<EOF    
  path "internal/data/database/config" {
     capabilities = ["read"]
  }
  EOF
```
```
  Success! Uploaded policy: readonly
```

Create role
```bash
  vault write auth/kubernetes/role/readonly \    
      bound_service_account_names=vault-auth \  
      bound_service_account_namespaces=default \
      policies=readonly \    
      ttl=24h
```
```
  Success! Data written to: auth/kubernetes/role/readonly
```

5. Inject secrets to pod
Update deployment
```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: {{ .Chart.Name }}
    labels:
      {{- include "common.labels" . | nindent 4 }}
      app-python/special-label: "app-python"
  spec:
    selector:
      matchLabels:
        app.kubernetes.io/name: {{ .Chart.Name }}
    template:
      metadata:
        labels:
          {{- include "common.labels" . | nindent 8 }}
      spec:
        serviceAccountName: internal-app
        containers:
          - name: {{ .Chart.Name }}
            image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
            ports:
              - name: http
                containerPort: {{ .Values.service.port }}
                protocol: TCP
            env:
              - name: MY_USER
                valueFrom:
                  secretKeyRef:
                    name: my-secret
                    key: MY_USER
              - name: MY_PASS
                valueFrom:
                  secretKeyRef:
                    name: my-secret
                    key: MY_PASS
```
Create patch
```yaml
  spec:
  template:
    metadata:
      annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "readonly"
        vault.hashicorp.com/agent-inject-secret-database-config.txt: 'internal/data/database/config'
```

```bash
  kubectl patch deployment app-python --patch "$(cat ./app-python/patch-inject-secrets.yaml)"
```
```
  deployment.apps/app-python patched
```

```bash
  kubectl exec -it app-python-575d5fd77d-7rdm7 -- bash  
```
```bash
  cat /vault/secrets/database-config.txt
```
```
data: map[password:db-secret-password username:db-readonly-username]
metadata: map[created_time:2025-03-08T20:24:45.802902427Z custom_metadata:<nil> deletion_time: destroyed:false version:1]
```

```bash
  df -h
```
```
Filesystem      Size  Used Avail Use% Mounted on
overlay         224G   53G  172G  24% /
tmpfs            64M     0   64M   0% /dev
shm              64M     0   64M   0% /dev/shm
tmpfs           5.9G  4.0K  5.9G   1% /vault/secrets
/dev/vdb1       224G   53G  172G  24% /etc/hosts
tmpfs            12G   12K   12G   1% /run/secrets/kubernetes.io/serviceaccount
tmpfs           5.9G     0  5.9G   0% /sys/firmware
```

# Bonus

1. Set limits
```yaml
  resources:
    requests:
      cpu: "500m"
      memory: "256Mi"
    limits:
      cpu: "1"
      memory: "512Mi"
```
2. Update deployment
```bash
  helm upgrade --install app-python ./app-python -n default -f ./app-python/values.yaml
```
3. Verify patch
```bash
  kubectl describe pod app-python-6c585ff4b9-jcg8k -n default -n default
```
```
Name:             app-python-6c585ff4b9-jcg8k
Namespace:        default
Priority:         0
Service Account:  vault-auth
Node:             minikube/192.168.49.2
Start Time:       Sun, 09 Mar 2025 00:06:47 +0300
Labels:           app.kubernetes.io/instance=app-python
                  app.kubernetes.io/managed-by=Helm
                  app.kubernetes.io/name=app-python
                  app.kubernetes.io/version=0.1.0
                  helm.sh/chart=app-python-0.1.0
                  pod-template-hash=6c585ff4b9
Annotations:      <none>
Status:           Running
IP:               10.244.0.49
IPs:
  IP:           10.244.0.49
Controlled By:  ReplicaSet/app-python-6c585ff4b9
Containers:
  app-python:
    Container ID:   docker://be3ea4afa2bcd130f2a2a3546a11badbd554b41d4a4933df1cb3c0d488b07f70
    Image:          secretanry/python_app:latest
    Image ID:       docker-pullable://secretanry/python_app@sha256:6a778509853816e0f67369f0033ff37964c9215bdac93068522d40f007798c1b
    Port:           8000/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Sun, 09 Mar 2025 00:06:53 +0300
    Ready:          True
    Restart Count:  0
    Limits:
      cpu:     1
      memory:  512Mi
    Requests:
      cpu:     500m
      memory:  256Mi
    Environment:
      MY_USER:  <set to the key 'MY_USER' in secret 'my-secret'>  Optional: false
      MY_PASS:  <set to the key 'MY_PASS' in secret 'my-secret'>  Optional: false
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-9rcr5 (ro)
Conditions:
  Type                        Status
  PodReadyToStartContainers   True 
  Initialized                 True 
  Ready                       True 
  ContainersReady             True 
  PodScheduled                True 
Volumes:
  kube-api-access-9rcr5:
    Type:                    Projected (a volume that contains injected data from multiple sources)
    TokenExpirationSeconds:  3607
    ConfigMapName:           kube-root-ca.crt
    ConfigMapOptional:       <nil>
    DownwardAPI:             true
QoS Class:                   Burstable
Node-Selectors:              <none>
Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  2m38s  default-scheduler  Successfully assigned default/app-python-6c585ff4b9-jcg8k to minikube
  Normal  Pulling    2m37s  kubelet            Pulling image "secretanry/python_app:latest"
  Normal  Pulled     2m33s  kubelet            Successfully pulled image "secretanry/python_app:latest" in 4.053s (4.053s including waiting). Image size: 165617356 bytes.
  Normal  Created    2m32s  kubelet            Created container: app-python
  Normal  Started    2m32s  kubelet            Started container app-python
```

With app go corresponding correctives

4. Environment variables
Add environment to **values.yaml**
```yaml
  environment:
    course: Devops
    author: secretanry
```
Add helper
```
{{- define "app-python.environmentVars" -}}
- name: AUTHOR
  value: {{ .Values.environment.author | quote }}
- name: COURSE
  value: {{ .Values.environment.course | quote }}
{{- end}}
```
Add to deployment
```yaml
  env:
    {{- include "app-python.environmentVars" . | nindent 10 }}
```
The same actions for app go
